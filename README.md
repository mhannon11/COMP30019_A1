# COMP30019_A1
COMP30019 Graphics and Interaction Assignment 1.


----- Diamond-Square Algorithm Implementation -----

The Diamond-Square algorithm was implemented in the script 'GenerateLadnscape.cs'. Inside the script there is a function named 'DiamondSquare' which generates a height map using the algorithm. The height map was then applied to a terrain GameObject.

The function first randomaly generates a height for each of the corners in the range of the height of the terrain. The function then moves into a for loop which iterates over the algorithm through steps, each step is the application of the diamond and square averages for a given iteration, the for loop terminates when the algorithm has iterated over the smallest step.

During the diamond and square steps of each iteration a random value is added the average of the respective points. While implementing the algorithm it was learnt that this random value was one of the most important parts of creating realistic looking terrain, if the random value added to each average was too large then the generated terrain would be very jagged and not have a smooth transition between each point. So to get the best looking terrain the random values added needed to be scaled to each particular step, for example the random value generated for the first step would be in the range of the max height of the terrain, but a random value generated for the third step would be a in the range of a quarter of the max height of the terrain. A roughness constant is also factored in when generating the random values, for a mountainous terrain a higher constant is needed compared to a smoother terrain. The following equation is what was used:

    random = ((Random value between 0 and 1) * (roughness * step size) * 2.0) - (roughness * step size)
    
    Where roughness = 0.4

When intially implementing the algorithm there were problems with artifacts and areas on the generated heightmap which were outside of the range of the terrain height creating ugly flat ares at the highest points in the terrain. To counter this a function called 'generateValid' was created which generates the random value to be added to the averages during the diamond and square steps. This function only generates values to be added to the height map that would not exceed the height maximum when added the the averages. This got rid of the ugly flat areas of the terrain.

When implementing the algorithm an implementation made by a github user 'eogas' was referenced and some parts of the algorithm are based of this implementation.
https://github.com/eogas/DiamondSquare/blob/master/DiamondSquare/DiamondSquare/DiamondSquare.cs

When adding colour to the different heights of the terrain a video on splatmaps was used to learn how they work and to help make a basic implementation. This youtube video was made by the create 'Holistic3d'.
https://www.youtube.com/watch?v=aUcWm1k0xDc&ab_channel=Holistic3d


----- Geometry Representation of the Terrain -----

The representation of the height map generated by the Diamond-Square algorithm was created using the terrain GameObject. The Diamond-Square algorithm would output an array of floats representing the heights for each coordinate. In order to represent this the array was normalised, then applied to the mesh of the terrain using the terrrainData.SetHeights() function. This changed the heights for each vertex in the terrain mesh.

The final dimensions that were settled on were a width and height of 1024 x 1024, and a height of 512. These dimensions seemed to give the best representation of a mountain range while not being too big.


------ Camera Transformations -----

Camera Transformations all occur int he script 'CameraMove.cs'. To move the camera around rigidBody transformations were used so collision with the terrain and skybox were possible.

First, the script calculates the rotation of the camera depending on the coordinates of the user's cursor and a sensitivity constant to determine how for the camera rotates depending on how far the mouse is moved. The rotation in the Y-axis is also locked between -90 degrees and 90 degrees, this is so the user does not get disorientated when using the camera. This rotation is then applied to the camera.

Next, the script calculates the velocity of the camera depending if the 'wasd' keys are pressed and the rotation of the camera. If the w or a key is pressed then the camera's velocity in the direction it is facing is calculated appropriately. Similarily if the a or d keys are pressed then the camera;s velocity in perpindicular to the direction it is facing is calculated. This velocity is then applied to the camera.

In this script is also were the default camera angle and positioning are set so that each time the user generates a new terrain they are placed above the terrain in a corner so that you can see the whole terrain and sun.


----- Phong Illumination Model Paramaters -----

For the terrain and the water seperate shaders and paramaters were used. The terrain used 'TerrainShader.shader' and the water used 'WaterShader.shader'. The model implementation was based off of the workshop solutions.

For the terrain, the parameters were set to represent the properties of a mountain range as closely as possible. To achieve this the specular component of the model was set to only have small amounts of reflection, as the rock, grass and sand of a mountain are not shiny, but still have slight highlights as they are not completely matte in texture. The diffuse component of the model was set to reflect the roughness of the terrain of the terrain, having significant amounts of diffuse reflection.

Terrain Paramaters:
Ka = 0.3, Kd = 50, Ks = 1, n = 2

For the water, the paramaters were set to represent the shiny properties of water. The specular component of the model was set high to represent the shinyness of water, this leads to tighter highlights on the water surface. The diffuse component of the water was set relatively low as most of the light specularly reflects of the surface of water.

Water Paramaters:
Ka = 0.3, Kd = 1, Ks = 1, n = 200


----- Vertex Shader Implementation -----

For the wave effect on the water, the shader 'WaterShader.shader' was used.

In order to simulate the effect of a wave displacement of the vertexs in the y-axis was needed. To do this the vertex displacement was calculated based of the vertex's x coordinate and the time. This was inputed into a sine function in the vertex shader.

The aim of the displacement was to simulate the gentle crashing of water onto the terrain. So a sine function with a low frequency and a relatively low height was needed. After experimenting with multiple numbers, the best effect was achieved by using the following equation to calculate the displacement of each vertex in the y-axis.

    y = sin(v.vertex.x + Time.y) / 25